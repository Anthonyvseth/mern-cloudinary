# MERN Cloudinary
A simple client-side tool for uploading files with a MERN stack
<div>
    <img alt="cloudinary" src="https://cloudinary-res.cloudinary.com/image/upload/c_fill,w_770/dpr_auto,f_auto,fl_lossy,q_auto/Migrate_Blog_.png">
</div>

## Introduction
What is cloudinary and why should we use it?

Cloudinary is a cloud service that offers a solution to a web application's entire image management pipeline. It allows for easily uploading of images to the cloud and seamless delivery through a fast CDN (Content Delivery Network). This is incredibly valuable in that it allows the remote storage of large files with instant access in our applications. https://cloudinary.com/documentation

To start off, we'll need to create an account with cloudinary.
- https://cloudinary.com/

## Getting Started
Next we'll look at the options provided by a cloudinary account along with configurations and evironments. A few key things to note:
- Cloudinary Dashboard and API information
- Media Library
- Settings > Uploads > Upload Presets

`Fork` and `clone` this repository to start.
Make sure to `npm i` inside the root directory of this repo as well as within the client directory to install dependencies for both our client and API.
- `touch .env` inside our client directory. We will need to use this four our `REACT_APP` environment variables.
- We need 3 variables inside of our `.env`
```js
REACT_APP_API_URL='http://localhost:8000/api'
REACT_APP_CLOUD_NAME='yourCloudinaryName'
REACT_APP_UPLOAD_PRESET='yourPresetName'
```
- Finally, let's take a look around the folders of this application. How do our frontend and backend communicate?

## Client Based Widget
Cloudinary can be used both on the backend with `Node.js` and on the frontend. In this case, we will be using an upload widget provided by cloudinary. 
- https://cloudinary.com/documentation/upload_widget_reference
- Inside `client/public/index.html` of our React client, we need to add a script inside the `<head>` tag of our document to be able to use this. 
```js
<script src="https://widget.cloudinary.com/v2.0/global/all.js" type="text/javascript"></script>
```
- Now that we've imported the upload widget at the base level of our client, we can build out our Uploader component to take advantage of the capabilities it provides.
- In `Uploader.js` we need two env variables at the top of the file to start
```js
const CLOUD_NAME = process.env.REACT_APP_CLOUD_NAME
const UPLOAD_PRESET = process.env.REACT_APP_UPLOAD_PRESET
```
- Next we will create our cloudinary upload widget inside the `Uploader` functional component.
```js
const widget = window.cloudinary.createUploadWidget(
    {},
    (error, result) => {})
```
- This widget takes 2 arguments. The first is for the configuration of our widget and the second is for a callback function that will return data from cloudinary.
- The two configuration key values absolutely required to use this widget are `cloudName` and `uploadPreset`. Let's use our env variables for these.
```js
const widget = window.cloudinary.createUploadWidget(
    {
       cloudName: CLOUD_NAME, 
       uploadPreset: UPLOAD_PRESET
    },
    (error, result) => {})
```
- Next, we can add a few more. These are optional, but in this case I wanted to limit filesizes to 1.5 MB, set file types allowed to images, and limit uploads to one file at a time.
```js
multiple: false,
resourceType: "image", 
maxFileSize: 1500000
```
- That should do it for the widget configuration for now. We'll set a callback function later, but first let's define one.
- Below the widget, we will make a function called `checkUpload` that will recieve the data generated by our widget and send the data we want from it to our API.
- Inside we have a conditional to see if the resultEvent that will be created by our upload widget is successful. 
```js
const checkUpload = async (resultEvent) => {
    if (resultEvent.event === 'success') {
      
    }
 }
 ```
 - If the event was a success, we will need to send this data to our API.
 - In this case, we want the secure_url generated by cloudinary with our uploaded image.
 - Try `console.log`ing the `resultEvent.info` object first to see what data exists within it.
 ```js
 try {
    const url = await resultEvent.info.secure_url
    if (url) {
      await __UploadFile(url)
      await updateRender()
    } 
} 
catch(err) {throw err}
``` 
- Now, inside the anonymous callback of our widget, let's add our `checkUpload` function.
```js
(error, result) => {checkUpload(result)}
```
- Since we'll be calling on `updateRender()` as well, we can define it below our `checkUpload` function.
```js
const updateRender = async () => {
    await props.setImages()
}
```
- One last thing to bring our upload widget into existence. Let's create a button that will open our widget `onClick` inside the return of our functional component.
```js
<button className="btn indigo darken-3" onClick={() => widget.open()}><i className="material-icons left">cloud_upload</i>Upload file</button>
```
- And with that, our upload widget should be fully functional!

To see if your upload widget is working, you'll need to start your server from the root directory of this project, then run `npm start` from within the `client` directory to start the frontend development server.

### I hope you find this tool useful! Feel free to refactor in any way you see fit, this is only an example!
